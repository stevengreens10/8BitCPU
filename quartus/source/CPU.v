
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module CPU(
	input clk,
	input reset,
	input [7:0] DATA_IN_BUS,

	output WRITE_EN,
	output [7:0] ADDR_OUT_BUS,
	output [7:0] DATA_OUT_BUS,
	output [7:0] DEBUG
);

//=======================================================
//  REG/WIRE declarations
//=======================================================

// =============== BUSES ===============

wire [7:0] DATA_BUS;
wire [7:0] ADDR_BUS;
wire [7:0] DECODER_IN;

// ALU -> ACC connection
wire [7:0] ALU_ACC_BUS;

// =============== SIGNALS ===============
// Data in signal
wire DATA_IN;
wire DATA_OUT;

// ALU signals
wire [3:0] ALU_OP;

// Register A signals
wire A_LATCH;
wire A_ENABLE;
wire A_READ_ALU; /* Latch from ALU instead of DATA bus */

// Register B signals
wire B_LATCH;
wire B_ENABLE;

// Instruction Pointer signals
wire IP_LATCH;
wire IP_ENABLE;
wire IP_INC;

// Instruction Register
wire IR_LATCH;

// Address Register signal(s)
wire ADDR_LATCH;

// Data Latch signals
wire D_LATCH;
wire D_ENABLE;
// Set high to increment contents of data latch
// Will be handy for fetching next byte from an address (16bit)
wire D_INC;
wire D_IN_SELECT;
wire D_OUT_SELECT;

// =============== DEBUG ===============
/* Always asserting reg values */
/* Mostly for debug purposes */
wire [7:0] A_REG;
wire [7:0] B_REG;
wire [7:0] IP_REG;
wire [7:0] INST; 	/* Current instruction */
wire [7:0] ADDR_REG;
wire [7:0] DATA_REG;


// =============== ASSIGNMENTS ===============
assign WRITE_EN = ~DATA_OUT;
assign DEBUG[7:0] = A_REG[7:0];

//=======================================================
//  Structural coding
//=======================================================

ALU ALU(
	.ACC_IN(A_REG),
	.DATA_IN(DATA_BUS),
	.op(ALU_OP),
	.ACC_OUT(ALU_ACC_BUS)
);

Register8 A_REGISTER(
    .clk(clk),
	.reset(reset),
	.latch(A_LATCH),
	.enable(A_ENABLE),
	.BUSA(DATA_BUS),
	.BUSB(ALU_ACC_BUS),
	.REG_OUT(A_REG),
	.inc(0),
	.inBusSelect(A_READ_ALU), /* Reads from DATA */
	.outBusSelect(0) /* Writes to DATA */
);

Register8 B_REGISTER(
    .clk(clk),
	.reset(reset),
	.latch(B_LATCH),
	.enable(B_ENABLE),
	.BUSA(DATA_BUS),
	.BUSB(),
	.REG_OUT(B_REG),
	.inc(0),
	.inBusSelect(0), /* Reads from DATA */
	.outBusSelect(0) /* Writes to DATA */
);

Register8 IP_REGISTER(
    .clk(clk),
	.reset(reset),
	.latch(IP_LATCH),
	.enable(IP_ENABLE),
	.BUSA(DATA_BUS),
	.BUSB(ADDR_BUS),
	.REG_OUT(IP_REG),
	.inc(IP_INC),
	.inBusSelect(0), /* Reads from DATA */
	.outBusSelect(1) /* Writes to ADDR */
);

Register8 INST_REGISTER(
    .clk(clk),
	.reset(reset),
	.latch(IR_LATCH),
	.enable(IP_ENABLE),
	.BUSA(DATA_BUS),
	.BUSB(DECODER_IN),
	.REG_OUT(INST),
	.inc(0),
	.inBusSelect(0), /* Reads from DATA */
	.outBusSelect(1) /* Writes to DECODER_IN */
);

InstructionDecoder INST_DECODER (
    .clk(clk),
	.reset(reset),
    .INST(INST),

	.DATA_IN(DATA_IN),
	.DATA_OUT(DATA_OUT),

	.ALU_OP(ALU_OP),

	.A_LATCH(A_LATCH),
	.A_ENABLE(A_ENABLE),
	.A_READ_ALU(A_READ_ALU),

	.B_LATCH(B_LATCH),
	.B_ENABLE(B_ENABLE),

	.IP_LATCH(IP_LATCH),
	.IP_ENABLE(IP_ENABLE),
	.IP_INC(IP_INC),

	.IR_LATCH(IR_LATCH),

	.ADDR_LATCH(ADDR_LATCH),

	.D_LATCH(D_LATCH),
	.D_ENABLE(D_ENABLE),
	.D_INC(D_INC),
	.D_IN_SELECT(D_IN_SELECT),
	.D_OUT_SELECT(D_OUT_SELECT)
);

AsyncRegister8 ADDR_REGISTER(
	.reset(reset),
	.latch(ADDR_LATCH),
	.enable(1), /* Always enabled */
	.BUSA(ADDR_BUS),
	.BUSB(ADDR_OUT_BUS),
	.REG_OUT(ADDR_REG),
	.inc(0),
	.inBusSelect(0), /* Reads from ADDR */
	.outBusSelect(1) /* Writes to ADDR_OUT */
);

Register8 DATA_REGISTER(
    .clk(clk),
	.reset(reset),
	.latch(D_LATCH),
	.enable(D_ENABLE),
	.BUSA(DATA_BUS),
	.BUSB(ADDR_BUS),
	.REG_OUT(DATA_REG),
	.inc(D_INC),
	.inBusSelect(D_IN_SELECT),
	.outBusSelect(D_OUT_SELECT)
);

// Asserts DATA_IN_BUS to DATA_BUS when DATA_IN is high
Buffer8 DATA_IN_BUFFER(
	.IN(DATA_IN_BUS),
	.OUT(DATA_BUS),
	.EN(DATA_IN)
);

// Asserts DATA_BUS to DATA_OUT_BUS when DATA_OUT is high
Buffer8 DATA_OUT_BUFFER(
	.IN(DATA_BUS),
	.OUT(DATA_OUT_BUS),
	.EN(DATA_OUT)
);

endmodule
